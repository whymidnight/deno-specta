use specta::{functions::FunctionDataType, ts::TsExportError, ExportError, TypeDefs};
use std::{
    fs::{self, File},
    io::Write,
    path::{Path, PathBuf},
};

/// Building blocks for [`export`] and [`export_with_cfg`].
///
/// Specta-enabled library.
pub mod internal {
    use heck::ToLowerCamelCase;
    use indoc::formatdoc;

    use specta::{
        functions::FunctionDataType,
        ts::{self, TsExportError},
    };

    const DO_NOT_EDIT: &str = "// This file was generated by [deno-specta](https://github.com/whymidnight/deno-specta). Do not edit this file manually.";

    /// Constants that the generated functions rely on
    pub fn globals() -> String {
        r#"  const { core } = Deno;
  const { ops } = core;
  core.initializeAsyncOps();

  function argsToMessage(...args) {
    return args.map((arg) => JSON.stringify(arg)).join(" ");
  }

  globalThis.console = {
    log: (...args) => {
      core.print(`[out]: ${argsToMessage(...args)}\n`, false);
    },
    error: (...args) => {
      core.print(`[err]: ${argsToMessage(...args)}\n`, true);
    },
  };"#
        .to_string()
    }

    /// begin globalThis
    pub fn begin() -> String {
        r#"((globalThis) => {"#.to_string()
    }

    /// end globalThis
    pub fn end() -> String {
        r#"})(globalThis);"#.to_string()
    }

    /*
              globalThis.runjs = {
                readFile: (path) => {
                  return ops.op_read_file(path);
                },
                writeFile: (path, contents) => {
                  return ops.op_write_file(path, contents);
                },
                removeFile: (path) => {
                  return ops.op_remove_file(path);
                },

                fetch: async (url) => {
                  return ops.op_fetch(url);
                },
              };

    */

    /// Renders a collection of [`FunctionDataType`] into a JavaScript string.
    pub fn render_functions(
        function_types: Vec<FunctionDataType>,
        cfg: &specta::ts::ExportConfiguration,
    ) -> Result<String, TsExportError> {
        function_types
            .into_iter()
            .map(|function| {
                let asyncness = match function.asyncness {
                    true => ["async", "await"],
                    false => ["", ""],
                };
                let name = &function.name;
                let name_camel = function.name.to_lower_camel_case();

                let arg_list = function
                    .args
                    .iter()
                    .map(|(name, _)| name.to_lower_camel_case())
                    .collect::<Vec<_>>();

                let arg_defs = arg_list.join(", ");

                let arg_usages = arg_list
                    .is_empty()
                    .then(Default::default)
                    .unwrap_or_else(|| arg_list.join(", "));

                let arg_jsdocs = function
                    .args
                    .iter()
                    .map(|(name, typ)| {
                        ts::datatype(cfg, typ).map(|typ| {
                            let name = name.to_lower_camel_case();

                            format!("\n    * @param {name}: {typ}")
                        })
                    })
                    .collect::<Result<Vec<_>, _>>()?
                    .join("");

                let ret_type = ts::datatype(cfg, &function.result)?;

                let _async = asyncness[0];
                let _await = asyncness[1];

                Ok(format! {
                    r#"    /* {arg_jsdocs}
    * @returns Promise<{ret_type}>
    */
    {name_camel}: {_async} ({arg_defs}) => {{
      return {_await} ops.{name}({arg_usages})
    }},"#
                })
            })
            .collect::<Result<Vec<_>, _>>()
            .map(|v| v.join("\n"))
    }

    /// Renders the output of [`globals`] and [`render_functions`] into a TypeScript string.
    pub fn render(
        function_types: Vec<FunctionDataType>,
        cfg: &specta::ts::ExportConfiguration,
    ) -> Result<String, TsExportError> {
        let begin = begin();
        let end = end();
        let globals = globals();

        let functions = render_functions(function_types, cfg)?;

        Ok(formatdoc! {
            r#"
                {DO_NOT_EDIT}

                {begin}
                {globals}

                  globalThis.runjs = {{
                {functions}
                  }};
                {end}
            "#
        })
    }
}

/// Exports the output of [`internal::render`] for a collection of [`FunctionDataType`] into a JavaScript file.
/// Allows for specifying a custom [`ExportConfiguration`](specta::ts::ExportConfiguration).
pub fn export_with_cfg(
    (function_types, _): (Vec<FunctionDataType>, TypeDefs),
    export_path: impl AsRef<Path>,
    cfg: specta::ts::ExportConfiguration,
) -> Result<(), TsExportError> {
    let export_path = PathBuf::from(export_path.as_ref());

    if let Some(export_dir) = export_path.parent() {
        fs::create_dir_all(export_dir)?;
    }

    let mut file = File::create(export_path)?;

    write!(file, "{}", internal::render(function_types, &cfg)?)?;

    Ok(())
}

/// Exports the output of [`internal::render`] for a collection of [`FunctionDataType`] into a JavaScript file.
pub fn export(
    macro_data: Result<(Vec<FunctionDataType>, TypeDefs), ExportError>,
    export_path: impl AsRef<Path>,
) -> Result<(), TsExportError> {
    export_with_cfg(macro_data?, export_path, Default::default())
}
